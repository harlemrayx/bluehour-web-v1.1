<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Blue Hour: Exposure Simulator</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      cursor: crosshair;
    }

    canvas {
      display: block;
    }

    /* 模拟相机的取景器 UI */
    #ui {
      position: absolute;
      bottom: 30px;
      left: 30px;
      color: #00ffcc;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      pointer-events: none;
      mix-blend-mode: difference;
      line-height: 1.5;
    }

    .label {
      opacity: 0.7;
      font-size: 10px;
    }

    .value {
      font-weight: bold;
    }

    a {
      color: #00ffcc;
      text-decoration: none;
      opacity: 0.5;
      font-size: 10px;
      pointer-events: auto;
    }

    a:hover {
      opacity: 1.0;
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <div id="ui">
    <div><span class="label">APERTURE: </span><span id="f-stop" class="value">f/--</span></div>
    <div><span class="label">SHUTTER: </span><span id="shutter" class="value">--</span></div>
    <div><span class="label">ISO: </span><span id="iso" class="value">--</span></div>
    <div style="margin-top:10px; opacity:0.5; font-size:10px;">MOUSE Y: APERTURE | MOUSE X: ISO | MOVEMENT: FLUID FLOW
    </div>
    <div style="margin-top:5px;"><a href="https://bluehour-web.vercel.app" target="_blank">bluehour-web.vercel.app</a>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderer = new THREE.WebGLRenderer({
      preserveDrawingBuffer: true
    }); // Enable Screenshot
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Screenshot Feature ---
    window.addEventListener('click', (e) => {
      // Check if clicking UI link
      if (e.target.tagName === 'A') return;

      const link = document.createElement('a');
      const date = new Date();
      const timestamp = date.toISOString().replace(/[:.]/g, '-');
      link.download = `bluehour-exposure-${timestamp}.png`;
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    });

    // --- Shader: 局部流体交互 + 光圈/ISO ---
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTime: {
          value: 0
        },
        uResolution: {
          value: new THREE.Vector2(window.innerWidth, window.innerHeight)
        },
        uMouse: {
          value: new THREE.Vector2(0.5, 0.5)
        },
        uMouseVel: {
          value: new THREE.Vector2(0.0, 0.0)
        }, // Flow Direction & Strength
        uHue: {
          value: 0.0
        }, // Dynamic Hue Shift based on interaction

        // Camera Params (Still kept for color/brightness logic)
        uAperture: {
          value: 0.5
        },
        uISO: {
          value: 0.0
        }
      },
      vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform float uTime;
                uniform vec2 uResolution;
                uniform vec2 uMouse;
                uniform vec2 uMouseVel;
                uniform float uAperture;
                uniform float uISO;
                uniform float uHue;
                varying vec2 vUv;

                // --- Noise Functions ---
                float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
                float noise (in vec2 st) {
                    vec2 i = floor(st); vec2 f = fract(st);
                    float a = random(i); float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                #define OCTAVES 6
                float fbm (in vec2 st) {
                    float value = 0.0; float amplitude = .5;
                    for (int i = 0; i < OCTAVES; i++) {
                        value += amplitude * noise(st); st *= 2.; amplitude *= .5;
                    }
                    return value;
                }

                // Hue Rotation Function
                vec3 hueShift(vec3 color, float hue) {
                    if (hue == 0.0) return color;
                    const vec3 k = vec3(0.57735, 0.57735, 0.57735);
                    float cosAngle = cos(hue);
                    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));
                }

                void main() {
                    vec2 st = gl_FragCoord.xy/uResolution.xy;
                    float ratio = uResolution.x / uResolution.y;
                    st.x *= ratio;
                    
                    vec2 mousePos = uMouse;
                    mousePos.x *= ratio;

                    // --- Localized Fluid Interaction (局部交互) ---
                    // 计算到鼠标的距离
                    float dist = distance(st, mousePos);
                    
                    // 影响范围 (Influence Radius)
                    // 半径约 0.4，边缘平滑
                    float influence = smoothstep(0.4, 0.0, dist);
                    
                    // --- Water Ripple Logic (水面涟漪) ---
                    // User Req: Trigger ripples even at slow speeds, with intensity variation.
                    // 1. Calculate Wave Phase (expanding rings)
                    // High frequency (60.0) -> Tight ripples
                    // Time (-uTime * 15.0) -> Outward expansion
                    float wavePhase = dist * 60.0 - uTime * 15.0;
                    float wave = sin(wavePhase);
                    
                    // 2. Calculate Intensity based on Speed
                    // Use a non-linear curve to boost visibility of slow movements
                    float speed = length(uMouseVel);
                    float rippleIntensity = smoothstep(0.0, 0.5, speed * 20.0); // Boost low speed
                    
                    // 3. Mask Decay (Distance falloff)
                    float mask = exp(-dist * 8.0);
                    
                    // 4. Combine Linear Push + Radial Ripple
                    // Linear Push: Directional flow (uMouseVel)
                    // Radial Ripple: Omni-directional wave (normalize(st - mousePos))
                    vec2 rippleDir = normalize(st - mousePos);
                    
                    // Total Warp
                    // Base Push: uMouseVel * influence * 2.0
                    // Ripple: rippleDir * wave * mask * rippleIntensity * 0.05
                    vec2 warp = (uMouseVel * influence * 2.5) + (rippleDir * wave * mask * rippleIntensity * 0.05);

                    // 应用扭曲到 FBM 坐标
                    vec2 q = vec2(fbm(st - warp + vec2(0.0, uTime * 0.05)), fbm(st + vec2(5.2,1.3)));
                    vec2 r = vec2(fbm(st + 4.0*q + vec2(1.7,9.2) - warp), fbm(st + 4.0*q + vec2(8.3,2.8)));
                    float f = fbm(st + 4.0*r);

                    // --- Visuals (色彩) ---
                    // Deep Blue Hour Palette
                    vec3 color1 = vec3(0.02, 0.04, 0.15); // Deep Indigo
                    vec3 color2 = vec3(0.1, 0.5, 0.8);    // Ocean Blue
                    vec3 color3 = vec3(1.0, 0.7, 0.4);    // Sunset Peach (Highlight)

                    // 基础混合
                    vec3 color = mix(color1, color2, f);
                    
                    // 高光 (Highlights)
                    // User Request: No glowing around mouse, only physical warp.
                    // Removed 'turbulence * influence' which created the mouse glow.
                    float highlight = pow(f, 3.0); 
                    color = mix(color, color3, highlight * 0.6);

                    // --- ISO / Aperture Simulation (Subtle) ---
                    // ISO Noise
                    float grain = (random(st * uTime * 2.0) - 0.5) * uISO * 0.3;
                    color += grain;
                    
                    // Exposure Adjustment
                    color *= (1.2 + uISO); 

                    // --- Dynamic Hue Shift ---
                    color = hueShift(color, uHue);

                    gl_FragColor = vec4(color, 1.0);
                }
            `
    });

    const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
    scene.add(plane);

    // --- Interaction Logic ---
    const mouse = new THREE.Vector2(0.5, 0.5);
    const targetVel = new THREE.Vector2(0, 0);
    const currentVel = new THREE.Vector2(0, 0);

    const uiFStop = document.getElementById('f-stop');
    const uiShutter = document.getElementById('shutter');
    const uiIso = document.getElementById('iso');

    // 上一次的原始鼠标位置
    let lastClientOp = new THREE.Vector2(0, 0);
    let firstMove = true;

    document.addEventListener('mousemove', (e) => {
      // Update Mouse Position (0..1)
      mouse.x = e.clientX / window.innerWidth;
      mouse.y = 1.0 - (e.clientY / window.innerHeight);

      if (firstMove) {
        lastClientOp.set(e.clientX, e.clientY);
        firstMove = false;
        return;
      }

      // Calculate Velocity
      // 使用 movementX/Y 有时会有兼容性问题或跳跃，改为手动计算差值
      let dx = e.clientX - lastClientOp.x;
      let dy = e.clientY - lastClientOp.y; // 屏幕坐标Y向下

      // 归一化这一帧的移动量
      // Shader里：Y向上。屏幕：Y向下。
      // 我们希望鼠标向上移(dy < 0)时，推动流体向上(warp y > 0)
      // 或者看个人喜好，这里设定为跟随方向
      targetVel.x = dx * 0.005;
      targetVel.y = -dy * 0.005; // 反转Y

      lastClientOp.set(e.clientX, e.clientY);
    });

    const clock = new THREE.Clock();

    let currentHue = 0.0;
    let targetHue = 0.0;

    function animate() {
      requestAnimationFrame(animate);

      // Smooth / Delay Logic (物理惯性 + Extended Delay)
      // 极低系数 = 像蜜糖一样粘稠
      currentVel.x += (targetVel.x - currentVel.x) * 0.05;
      currentVel.y += (targetVel.y - currentVel.y) * 0.05;

      // 阻尼衰减 (即使鼠标不动，流体也慢慢停下来)
      // User REQ: Extend Shutter Speed Delay (Hold parameters for seconds)
      // Use vary slow decay factor (0.995 instead of 0.9) to make it linger for ~5-10s
      targetVel.x *= 0.995;
      targetVel.y *= 0.995;

      // Dynamic Hue Logic
      // Based on accumulated velocity or current movement magnitude
      // Let's shift hue slightly when 'fast' movement happens
      const velMag = currentVel.length();
      targetHue = velMag * 5.0; // Scale intensity
      currentHue += (targetHue - currentHue) * 0.05;

      // Update Uniforms
      material.uniforms.uTime.value = clock.getElapsedTime();
      material.uniforms.uMouse.value.copy(mouse);

      // Pass smoothed velocity
      material.uniforms.uMouseVel.value.copy(currentVel);

      // Maintain ISO/Aperture mapping
      material.uniforms.uISO.value = mouse.x;
      material.uniforms.uAperture.value = mouse.y;

      // Update Hue
      material.uniforms.uHue.value = currentHue;

      // UI Updates
      updateUI(mouse.y, mouse.x);

      renderer.render(scene, camera);
    }

    function updateUI(aperture, iso) {
      // ISO Display
      const isoVal = Math.floor(100 * Math.pow(2, iso * 5));
      uiIso.innerText = isoVal;
      if (iso > 0.8) uiIso.style.color = "red";
      else uiIso.style.color = "#00ffcc";

      // Aperture Display
      const fStops = [1.4, 2.0, 2.8, 4.0, 5.6, 8.0, 11, 16, 22];
      const fIndex = Math.floor((1.0 - aperture) * (fStops.length - 1));
      uiFStop.innerText = "f/" + fStops[Math.max(0, Math.min(fIndex, fStops.length - 1))];

      // Shutter Display (Auto)
      uiShutter.innerText = "FLUID";
    }

    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>