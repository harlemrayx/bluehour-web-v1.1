<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Blue Hour: The Medium is the Massage</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        /* UI Overlay - Blue Hour Style */
        #ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            mix-blend-mode: difference;
            line-height: 1.5;
            z-index: 10;
        }

        .label {
            opacity: 0.7;
            font-size: 10px;
        }

        .value {
            font-weight: bold;
        }

        a {
            color: #00ffcc;
            text-decoration: none;
            opacity: 0.5;
            font-size: 10px;
            pointer-events: auto;
        }

        a:hover {
            opacity: 1.0;
            text-decoration: underline;
        }

        /* Hidden Content Canvas (Used as Texture) */
        #content-layer {
            display: none;
            /* set to block to debug */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div><span class="label">MEDIUM: </span><span id="f-stop" class="value">FLUID</span></div>
        <div><span class="label">MESSAGE: </span><span id="shutter" class="value">DISTORTED</span></div>
        <div><span class="label">ENTROPY: </span><span id="iso" class="value">RISING</span></div>
        <div style="margin-top:10px; opacity:0.5; font-size:10px;" id="status-line">MOUSE: INTERFERE | MOVEMENT: LIQUEFY
            CONTENT
        </div>
        <div style="margin-top:5px;"><a href="https://bluehour-web.vercel.app"
                target="_blank">bluehour-web.vercel.app</a></div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Configuration ---
        const CONFIG = {
            TEXTURE_DOWNSAMPLE: 1,
            DENSITY_DISSIPATION: 0.98,
            VELOCITY_DISSIPATION: 0.99, // Keep velocity longer for more swirls
            PRESSURE_ITERATIONS: 20,
            SPLAT_RADIUS: 0.005,
            CURL: 30,
        };

        // --- Content Manager: The "Message" Generator ---
        const ContentManager = {
            canvas: document.createElement('canvas'),
            ctx: null,
            width: 1024, // Texture resolution
            height: 1024,
            init() {
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                // this.canvas.id = 'content-layer'; // For debug
                // document.body.appendChild(this.canvas); // For debug

                this.ctx = this.canvas.getContext('2d');
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                // Initial content
                for (let i = 0; i < 3; i++) this.spawn();
            },

            // "Media Theory" Database
            texts: [
                "THE MEDIUM IS THE MASSAGE",
                "WE SHAPE OUR TOOLS",
                "AND AFTERWARDS THEY SHAPE US",
                "INFORMATION OVERLOAD",
                "GLOBAL VILLAGE",
                "THE EXTENSION OF MAN",
                "HOT MEDIA / COLD MEDIA",
                "ALL MEDIA ARE EXTENSIONS",
                "OF SOME HUMAN FACULTY",
                "THE CONTENT OF A MEDIUM",
                "IS ALWAYS ANOTHER MEDIUM",
                "SIMULACRUM",
                "HYPERREALITY",
                "NOISE RATIO",
                "SIGNAL LOST",
                "#BLUEHOUR",
                "SYSTEM FAILURE",
                "RECONNECTING...",
                "404 NOT FOUND",
                "USER DISCONNECTED",
                "CONSUME",
                "OBEY",
                "SCROLL",
                "LIKE",
                "SUBSCRIBE"
            ],

            spawn() {
                const ctx = this.ctx;
                const w = this.width;
                const h = this.height;

                // Random Position with border padding
                const margin = 100;
                const x = margin + Math.random() * (w - margin * 2);
                const y = margin + Math.random() * (h - margin * 2);
                const rot = (Math.random() - 0.5) * 0.5; // Slight rotation
                const scale = 0.8 + Math.random() * 1.0;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rot);
                ctx.scale(scale, scale);

                const type = Math.random();

                if (type < 0.6) {
                    // Type A: Text Post (Tweet/Headline)
                    // Random Style
                    const isInvert = Math.random() > 0.8;

                    if (isInvert) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-150, -30, 300, 60);
                        ctx.fillStyle = '#000000';
                    } else {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#00ffcc';
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.shadowBlur = 15;
                    }

                    ctx.font = "bold 28px Courier New";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    const text = this.texts[Math.floor(Math.random() * this.texts.length)];
                    ctx.fillText(text, 0, 0);

                    // timestamp
                    if (!isInvert) {
                        ctx.font = "10px Arial";
                        ctx.fillStyle = "rgba(255,255,255,0.5)";
                        ctx.shadowBlur = 0;
                        ctx.fillText("JUST NOW", 0, 30);
                    }

                } else if (type < 0.85) {
                    // Type B: Image Placeholder (Rectangle)
                    const rw = 200 + Math.random() * 150;
                    const rh = 150 + Math.random() * 150;

                    // Gradient fill simulates an image
                    const grad = ctx.createLinearGradient(-rw / 2, -rh / 2, rw / 2, rh / 2);
                    const hue = Math.random() * 360;
                    grad.addColorStop(0, `hsl(${hue}, 60%, 50%)`);
                    grad.addColorStop(1, `hsl(${hue + 40}, 60%, 20%)`);

                    ctx.fillStyle = grad;
                    ctx.shadowColor = `hsl(${hue}, 80%, 60%)`;
                    ctx.shadowBlur = 20;
                    ctx.fillRect(-rw / 2, -rh / 2, rw, rh);

                    // Fake UI overlay
                    ctx.fillStyle = "rgba(0,0,0,0.3)";
                    ctx.fillRect(-rw / 2, rh / 2 - 40, rw, 40);

                    // Play icon
                    ctx.fillStyle = "#fff";
                    ctx.beginPath();
                    ctx.moveTo(-10, rh / 2 - 30);
                    ctx.lineTo(15, rh / 2 - 20);
                    ctx.lineTo(-10, rh / 2 - 10);
                    ctx.fill();

                } else {
                    // Type C: Glitch / Error Block
                    const size = 50 + Math.random() * 100;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff0055' : '#0055ff';
                    ctx.globalCompositeOperation = "difference";
                    ctx.fillRect(-size / 2, -size / 2, size, size);
                }

                ctx.restore();
            },

            update() {
                // 1. Decay (Entropy): Fade out everything slightly
                this.ctx.globalCompositeOperation = "source-over";

                // If there's a lot of mouse movement (chaos), fade faster?
                // For now constant decay.
                this.ctx.fillStyle = "rgba(0, 0, 0, 0.015)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                // 2. Spawn new content occasionally
                // 3% chance per frame (~2 per second at 60fps)
                if (Math.random() < 0.03) {
                    this.spawn();
                }
            }
        };

        ContentManager.init();


        // --- Shaders ---

        const baseVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        // --- Display Shader: Fluid + Distorted Content ---
        const displayShader = `
            uniform sampler2D uTexture;     // Fluid Density
            uniform sampler2D uVelocity;    // Fluid Velocity
            uniform sampler2D uContent;     // Social Media Content Layer
            uniform float uTime;
            uniform vec2 uResolution;
            
            varying vec2 vUv;
            
            // Noise & FBM
            float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
            float noise (in vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            #define OCTAVES 4
            float fbm (in vec2 st) {
                float value = 0.0; float amplitude = .5;
                for (int i = 0; i < OCTAVES; i++) {
                    value += amplitude * noise(st); st *= 2.; amplitude *= .5;
                }
                return value;
            }

            void main() {
                vec2 uv = vUv;
                
                // 1. Get Velocity for Distortion
                vec2 vel = texture2D(uVelocity, uv).xy;
                float speed = length(vel);

                // 2. Distort UVs for Content
                // The stronger the flow, the more the content warps "physically"
                // We distort the UV lookup for the content texture using the fluid velocity
                
                // Distort factor:
                float distortStrength = 0.2; 
                vec2 distortion = vel * distortStrength; 
                vec2 contentUV = uv - distortion; 
                
                // Chromatic Aberration based on speed (The "Glitch" of the medium)
                float shift = speed * 0.04;
                float r = texture2D(uContent, contentUV + vec2(shift, 0.0)).r;
                float g = texture2D(uContent, contentUV).g;
                float b = texture2D(uContent, contentUV - vec2(shift, 0.0)).b;
                vec3 contentColor = vec3(r, g, b);

                // 3. Fluid Background (The Blue Hour Mood)
                // Use density to brighten the background slightly
                vec3 density = texture2D(uTexture, uv).rgb;
                float fluidAmt = length(density);
                
                float n = fbm(uv * 2.0 + uTime * 0.05 + vel * 0.2);
                vec3 fluidBase = vec3(0.01, 0.02, 0.08); // Deep Background
                vec3 fluidHighlight = vec3(0.05, 0.15, 0.3); // Swirl color
                vec3 bg = mix(fluidBase, fluidHighlight, n + fluidAmt * 0.5);

                // 4. Blend Content into Fluid
                // We want the content to feel "luminescent" but submerged.
                // Screen blend or additive.
                
                // If velocity is high, the content gets blurry/noisy (already handled by UV distortion sampling)
                
                vec3 finalColor = bg + contentColor * (0.8 + n * 0.4); 

                // 5. Post-Processing
                // Vignette
                float vignette = 1.0 - length(uv - 0.5) * 1.2;
                finalColor *= clamp(vignette, 0.2, 1.0);
                
                // Grain
                finalColor += (random(uv * uTime) - 0.5) * 0.03;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // ... Standard Sim Shaders ...
        const splatShader = `
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `;
        const advectionShader = `uniform sampler2D uVelocity; uniform sampler2D uSource; uniform vec2 texelSize; uniform float dt; uniform float dissipation; varying vec2 vUv; void main() { vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize; gl_FragColor = dissipation * texture2D(uSource, coord); }`;
        const divergenceShader = `uniform sampler2D uVelocity; uniform vec2 texelSize; varying vec2 vUv; void main() { float L = texture2D(uVelocity, vUv - vec2(texelSize.x, 0.0)).x; float R = texture2D(uVelocity, vUv + vec2(texelSize.x, 0.0)).x; float T = texture2D(uVelocity, vUv + vec2(0.0, texelSize.y)).y; float B = texture2D(uVelocity, vUv - vec2(0.0, texelSize.y)).y; float div = 0.5 * (R - L + T - B); gl_FragColor = vec4(div, 0.0, 0.0, 1.0); }`;
        const pressureShader = `uniform sampler2D uPressure; uniform sampler2D uDivergence; uniform vec2 texelSize; varying vec2 vUv; void main() { float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x; float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x; float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x; float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x; float C = texture2D(uPressure, vUv).x; float divergence = texture2D(uDivergence, vUv).x; float pressure = (L + R + T + B - divergence) * 0.25; gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0); }`;
        const gradientSubtractShader = `uniform sampler2D uPressure; uniform sampler2D uVelocity; uniform vec2 texelSize; varying vec2 vUv; void main() { float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x; float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x; float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x; float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x; vec2 velocity = texture2D(uVelocity, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(velocity, 0.0, 1.0); }`;

        // --- Application Setup ---

        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, preserveDrawingBuffer: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Content Texture
        const contentTexture = new THREE.CanvasTexture(ContentManager.canvas);
        contentTexture.minFilter = THREE.LinearFilter;
        contentTexture.magFilter = THREE.LinearFilter;

        let simWidth = window.innerWidth >> CONFIG.TEXTURE_DOWNSAMPLE;
        let simHeight = window.innerHeight >> CONFIG.TEXTURE_DOWNSAMPLE;
        let texelSize = new THREE.Vector2(1.0 / simWidth, 1.0 / simHeight);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
        scene.add(mesh);

        // --- FBO Helper ---
        function createFBO(w, h, type = THREE.HalfFloatType) {
            return new THREE.WebGLRenderTarget(w, h, {
                type: type,
                format: THREE.RGBAFormat,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                wrapS: THREE.ClampToEdgeWrapping,
                wrapT: THREE.ClampToEdgeWrapping,
                depthBuffer: false,
                stencilBuffer: false
            });
        }
        function createDoubleFBO(w, h, type) {
            let fbo1 = createFBO(w, h, type);
            let fbo2 = createFBO(w, h, type);
            return {
                read: fbo1, write: fbo2,
                swap: function () { let temp = this.read; this.read = this.write; this.write = temp; }
            };
        }

        let velocity = createDoubleFBO(simWidth, simHeight);
        let density = createDoubleFBO(simWidth, simHeight);
        let divergence = createFBO(simWidth, simHeight);
        let pressure = createDoubleFBO(simWidth, simHeight);

        // --- Materials ---
        const mat = {
            advection: new THREE.ShaderMaterial({
                uniforms: {
                    uVelocity: { value: null },
                    uSource: { value: null },
                    texelSize: { value: texelSize },
                    dt: { value: 0.016 },
                    dissipation: { value: CONFIG.VELOCITY_DISSIPATION }
                }, vertexShader: baseVertexShader, fragmentShader: advectionShader
            }),
            divergence: new THREE.ShaderMaterial({
                uniforms: { uVelocity: { value: null }, texelSize: { value: texelSize } },
                vertexShader: baseVertexShader, fragmentShader: divergenceShader
            }),
            pressure: new THREE.ShaderMaterial({
                uniforms: { uPressure: { value: null }, uDivergence: { value: null }, texelSize: { value: texelSize } },
                vertexShader: baseVertexShader, fragmentShader: pressureShader
            }),
            gradientSubtract: new THREE.ShaderMaterial({
                uniforms: { uPressure: { value: null }, uVelocity: { value: null }, texelSize: { value: texelSize } },
                vertexShader: baseVertexShader, fragmentShader: gradientSubtractShader
            }),
            splat: new THREE.ShaderMaterial({
                uniforms: {
                    uTarget: { value: null },
                    aspectRatio: { value: simWidth / simHeight },
                    color: { value: new THREE.Vector3() },
                    point: { value: new THREE.Vector2() },
                    radius: { value: CONFIG.SPLAT_RADIUS }
                }, vertexShader: baseVertexShader, fragmentShader: splatShader
            }),
            display: new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: null },
                    uVelocity: { value: null },
                    uContent: { value: contentTexture },
                    uTime: { value: 0.0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                }, vertexShader: baseVertexShader, fragmentShader: displayShader
            })
        };

        // --- Interaction ---
        const mouse = new THREE.Vector2(0.5, 0.5);
        const lastMouse = new THREE.Vector2(0.5, 0.5);

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX / window.innerWidth;
            mouse.y = 1.0 - (e.clientY / window.innerHeight);
        });

        // Touch support
        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouse.x = e.touches[0].clientX / window.innerWidth;
                mouse.y = 1.0 - (e.touches[0].clientY / window.innerHeight);
            }
        });

        function splat(dest, source, point, color) {
            mesh.material = mat.splat;
            mat.splat.uniforms.uTarget.value = source.texture;
            mat.splat.uniforms.point.value = point;
            mat.splat.uniforms.color.value = color;
            renderer.setRenderTarget(dest);
            renderer.render(scene, camera);
        }

        function step(dt) {
            // 1. Advect Velocity
            mesh.material = mat.advection;
            mat.advection.uniforms.dissipation.value = CONFIG.VELOCITY_DISSIPATION;
            mat.advection.uniforms.uVelocity.value = velocity.read.texture;
            mat.advection.uniforms.uSource.value = velocity.read.texture;
            renderer.setRenderTarget(velocity.write);
            renderer.render(scene, camera);
            velocity.swap();

            // 2. Advect Density
            mat.advection.uniforms.dissipation.value = CONFIG.DENSITY_DISSIPATION;
            mat.advection.uniforms.uVelocity.value = velocity.read.texture;
            mat.advection.uniforms.uSource.value = density.read.texture;
            renderer.setRenderTarget(density.write);
            renderer.render(scene, camera);
            density.swap();

            // 3. Divergence
            mesh.material = mat.divergence;
            mat.divergence.uniforms.uVelocity.value = velocity.read.texture;
            renderer.setRenderTarget(divergence);
            renderer.render(scene, camera);

            // 4. Pressure
            mesh.material = mat.pressure;
            mat.pressure.uniforms.uDivergence.value = divergence.texture;
            let pRead = pressure.read;
            let pWrite = pressure.write;
            for (let i = 0; i < CONFIG.PRESSURE_ITERATIONS; i++) {
                mat.pressure.uniforms.uPressure.value = pRead.texture;
                renderer.setRenderTarget(pWrite);
                renderer.render(scene, camera);
                let temp = pRead; pRead = pWrite; pWrite = temp;
            }
            pressure.read = pRead;
            pressure.write = pWrite;

            // 5. Gradient Subtract
            mesh.material = mat.gradientSubtract;
            mat.gradientSubtract.uniforms.uPressure.value = pressure.read.texture;
            mat.gradientSubtract.uniforms.uVelocity.value = velocity.read.texture;
            renderer.setRenderTarget(velocity.write);
            renderer.render(scene, camera);
            velocity.swap();

            // 6. Display
            mesh.material = mat.display;
            mat.display.uniforms.uTexture.value = density.read.texture;
            mat.display.uniforms.uVelocity.value = velocity.read.texture;
            mat.display.uniforms.uTime.value = performance.now() * 0.001;

            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. Update Content
            ContentManager.update();
            contentTexture.needsUpdate = true; // Update GPU texture

            // 2. Interaction
            const dx = mouse.x - lastMouse.x;
            const dy = mouse.y - lastMouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0.0) {
                // Add Velocity (Invisible force)
                splat(velocity.write, velocity.read, mouse, new THREE.Vector3(dx, dy, 0.0).multiplyScalar(300.0));
                velocity.swap();

                // Add Density (Visible Blue Ink)
                // We add some ink so the user sees *something* even if no content is there,
                // but mostly the visual is the content distortion.
                // Let's make the "ink" very subtle or match the content?
                // Actually, let's keep it subtle blue ink.
                splat(density.write, density.read, mouse, new THREE.Vector3(0.1, 0.2, 0.8).multiplyScalar(0.005));
                density.swap();

                // Spawn extra content on rapid movement ("Information Overload")
                if (dist > 0.04) {
                    ContentManager.spawn();
                    document.getElementById('status-line').innerText = "STATUS: INFORMATION OVERLOAD";
                    document.getElementById('status-line').style.color = "#ff0055";
                } else {
                    document.getElementById('status-line').style.color = "#00ffcc";
                    document.getElementById('status-line').innerText = "MOUSE: INTERFERE | MOVEMENT: LIQUEFY CONTENT";
                }
            }
            lastMouse.copy(mouse);

            step(0.016);
        }

        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            mat.display.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);

            simWidth = window.innerWidth >> CONFIG.TEXTURE_DOWNSAMPLE;
            simHeight = window.innerHeight >> CONFIG.TEXTURE_DOWNSAMPLE;
            texelSize.set(1.0 / simWidth, 1.0 / simHeight);

            // Re-init FBOs? (Ideally yes, but expensive for quick resize. Just letting it stretch is ok for art.)
        });
    </script>
</body>

</html>