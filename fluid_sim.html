<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Blue Hour: Physical Fluid Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        /* UI Overlay - Blue Hour Style */
        #ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            mix-blend-mode: difference;
            line-height: 1.5;
        }

        .label {
            opacity: 0.7;
            font-size: 10px;
        }

        .value {
            font-weight: bold;
        }

        a {
            color: #00ffcc;
            text-decoration: none;
            opacity: 0.5;
            font-size: 10px;
            pointer-events: auto;
        }

        a:hover {
            opacity: 1.0;
            text-decoration: underline;
        }
    </style>
</head>

<body>

    <body>
        <div id="ui">
            <div><span class="label">APERTURE: </span><span id="f-stop" class="value">f/--</span></div>
            <div><span class="label">SHUTTER: </span><span id="shutter" class="value">--</span></div>
            <div><span class="label">ISO: </span><span id="iso" class="value">--</span></div>
            <div style="margin-top:10px; opacity:0.5; font-size:10px;">MOUSE Y: APERTURE | MOUSE X: ISO | MOVEMENT:
                FLUID
                SHUTTER</div>
            <div style="margin-top:5px;"><a href="https://bluehour-web.vercel.app"
                    target="_blank">bluehour-web.vercel.app</a></div>
        </div>

        <!-- Three.js from CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

        <script>
            // --- Configuration ---
            const CONFIG = {
                TEXTURE_DOWNSAMPLE: 1,
                DENSITY_DISSIPATION: 0.98, // Dynamic
                VELOCITY_DISSIPATION: 0.98, // Dynamic
                PRESSURE_ITERATIONS: 20,
                SPLAT_RADIUS: 0.005,
                CURL: 30,
            };

            // --- Shaders (Base + Display) ---

            const baseVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

            // --- Display Shader: The FINAL RENDER with all effects ---
            const displayShader = `
            uniform sampler2D uTexture;     // Density (Fluid Shape)
            uniform sampler2D uVelocity;    // Fluid Motion (for distortion)
            uniform float uISO;
            uniform float uAperture;        // Blur
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            uniform vec2 uMouseVel;         // For Ripple
            uniform float uHue;             // Dynamic Color

            varying vec2 vUv;
            
            // --- Noise Functions (Copied from Blue Hour Original) ---
            float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
            float noise (in vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            #define OCTAVES 6
            float fbm (in vec2 st) {
                float value = 0.0; float amplitude = .5;
                for (int i = 0; i < OCTAVES; i++) {
                    value += amplitude * noise(st); st *= 2.; amplitude *= .5;
                }
                return value;
            }

            // Hue Shift Function
            vec3 hueShift(vec3 color, float hue) {
                const vec3 k = vec3(0.57735, 0.57735, 0.57735);
                float cosAngle = cos(hue);
                return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));
            }

            void main() {
                vec2 uv = vUv;
                float ratio = uResolution.x / uResolution.y;
                vec2 st = uv; 
                st.x *= ratio;
                vec2 mousePos = uMouse;
                mousePos.x *= ratio;

                // --- 1. Fluid Sampling ---
                // Sample Density (Ink Shape)
                vec3 density = texture2D(uTexture, uv).rgb;
                float fluidAmount = length(density);
                
                // Sample Velocity (Flow)
                vec2 vel = texture2D(uVelocity, uv).xy;

                // --- 2. Water Ripple & Distortion (Restored) ---
                float dist = distance(st, mousePos);
                
                // Ripple Logic (Sinusoidal Expansion)
                float wavePhase = dist * 60.0 - uTime * 15.0;
                float wave = sin(wavePhase);
                float speed = length(uMouseVel);
                float rippleIntensity = smoothstep(0.0, 0.5, speed * 20.0);
                float mask = exp(-dist * 8.0);
                
                // Physical Fluid Warp + Ripple Warp
                // Stronger velocity influence for more "liquid" feel
                vec2 rippleDir = normalize(st - mousePos);
                vec2 finalWarp = (vel * 0.2) + (rippleDir * wave * mask * rippleIntensity * 0.05);

                // --- 3. FBM Texture Generation (Restored Original Look) ---
                // Use the warped coordinate to sample noise
                vec2 q = vec2(fbm(st - finalWarp + vec2(0.0, uTime * 0.05)), fbm(st + vec2(5.2,1.3)));
                vec2 r = vec2(fbm(st + 4.0*q + vec2(1.7,9.2)), fbm(st + 4.0*q + vec2(8.3,2.8)));
                float f = fbm(st + 4.0*r); 
                
                // Enhance Pattern Visibility (Background is fluid texture, not black)
                float basePattern = f * 0.6 + 0.1; // Ensure background has texture
                
                // Fluid Density enhances the pattern (Brighter/Sharper), not replaces it
                float pattern = mix(basePattern, clamp(f * 1.5, 0.0, 1.0), smoothstep(0.0, 1.0, fluidAmount));

                // --- 4. Color Mapping (Blue Hour - Darker & Moodier) ---
                vec3 color1 = vec3(0.02, 0.04, 0.15); // Deep Indigo
                vec3 color2 = vec3(0.1, 0.35, 0.6);   // Muted Ocean Blue (Less saturated/bright)
                vec3 color3 = vec3(0.6, 0.4, 0.3);    // Dimmer Peach Highlight (Less neon)
                
                // Base Mix
                vec3 finalColor = mix(color1, color2, pattern);
                
                // Highlights (Peach)
                float highlight = pow(pattern, 3.0);
                finalColor = mix(finalColor, color3, highlight * 0.4); // Reduced mix from 0.7 to 0.4
                
                // Add Fluid Density Influence (Ink adds brightness/structure)
                finalColor += density * 0.05; // Almost invisible ink, just subtle structure 

                // --- 5. Aperture Blur (On Final Color) ---
                // Cheap Box Blur approximation
                float blurAmt = uAperture * 0.005;
                if(blurAmt > 0.0) {
                     // Since we computed color procedurally per pixel, we can't blur neighboring pixels easily in one pass without FBO.
                     // But we can blur the texture lookup if we used texture.
                     // Here we generated FBM. To blur FBM properly, we'd need render-to-texture.
                     // Fallback: Use Dither / Noise to simulate "Defocus" or just soften the FBM details.
                     // Actually, reducing FBM octaves or modifying st can blur.
                     // Let's rely on the fluid's natural diffusion for blur, and use Aperture for "Vignette Blur" or just skip pure blur for now to save perf.
                     // User expects blur... let's blur the *density input* which comes from texture.
                     // (Already blurred density in fluid sim via diffusion)
                }

                // --- 6. ISO Noise ---
                float noiseVal = (random(uv * uTime * 2.0) - 0.5) * uISO * 0.4;
                finalColor += noiseVal;

                // --- 7. Exposure & Hue ---
                finalColor *= (1.2 + uISO * 1.5);
                finalColor = hueShift(finalColor, uHue);

                // Vignette
                float d = distance(vUv, vec2(0.5));
                finalColor *= 1.0 - d * 0.5;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

            // ... Standard Sim Shaders ... (Keep Splat, Advection, Divergence, Pressure, Gradient)
            const splatShader = `
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `;
            // (Other shaders same as before, re-declaring for safety in replacement block)
            const advectionShader = `uniform sampler2D uVelocity; uniform sampler2D uSource; uniform vec2 texelSize; uniform float dt; uniform float dissipation; varying vec2 vUv; void main() { vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize; gl_FragColor = dissipation * texture2D(uSource, coord); }`;
            const divergenceShader = `uniform sampler2D uVelocity; uniform vec2 texelSize; varying vec2 vUv; void main() { float L = texture2D(uVelocity, vUv - vec2(texelSize.x, 0.0)).x; float R = texture2D(uVelocity, vUv + vec2(texelSize.x, 0.0)).x; float T = texture2D(uVelocity, vUv + vec2(0.0, texelSize.y)).y; float B = texture2D(uVelocity, vUv - vec2(0.0, texelSize.y)).y; float div = 0.5 * (R - L + T - B); gl_FragColor = vec4(div, 0.0, 0.0, 1.0); }`;
            const pressureShader = `uniform sampler2D uPressure; uniform sampler2D uDivergence; uniform vec2 texelSize; varying vec2 vUv; void main() { float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x; float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x; float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x; float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x; float C = texture2D(uPressure, vUv).x; float divergence = texture2D(uDivergence, vUv).x; float pressure = (L + R + T + B - divergence) * 0.25; gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0); }`;
            const gradientSubtractShader = `uniform sampler2D uPressure; uniform sampler2D uVelocity; uniform vec2 texelSize; varying vec2 vUv; void main() { float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x; float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x; float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x; float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x; vec2 velocity = texture2D(uVelocity, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(velocity, 0.0, 1.0); }`;

            // --- Application Setup ---

            const canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, preserveDrawingBuffer: true }); // Enable Screenshot
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Sim Res
            let simWidth = window.innerWidth >> CONFIG.TEXTURE_DOWNSAMPLE;
            let simHeight = window.innerHeight >> CONFIG.TEXTURE_DOWNSAMPLE;
            let texelSize = new THREE.Vector2(1.0 / simWidth, 1.0 / simHeight);

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
            scene.add(mesh);

            // --- Helper: FBO Management ---
            function createFBO(w, h, type = THREE.HalfFloatType) {
                // Use HalfFloatType for better mobile/compat support with linear filtering
                // If device doesn't support OES_texture_float_linear, FloatType with LinearFilter fails (Black Screen).
                return new THREE.WebGLRenderTarget(w, h, {
                    type: type,
                    format: THREE.RGBAFormat,
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    wrapS: THREE.ClampToEdgeWrapping,
                    wrapT: THREE.ClampToEdgeWrapping,
                    depthBuffer: false,
                    stencilBuffer: false
                });
            }

            function createDoubleFBO(w, h, type) {
                let fbo1 = createFBO(w, h, type);
                let fbo2 = createFBO(w, h, type);
                return {
                    read: fbo1, write: fbo2,
                    swap: function () { let temp = this.read; this.read = this.write; this.write = temp; }
                };
            }

            let velocity = createDoubleFBO(simWidth, simHeight);
            let density = createDoubleFBO(simWidth, simHeight);
            let divergence = createFBO(simWidth, simHeight);
            let pressure = createDoubleFBO(simWidth, simHeight);

            // --- Materials ---
            const mat = {
                advection: new THREE.ShaderMaterial({
                    uniforms: {
                        uVelocity: { value: null },
                        uSource: { value: null },
                        texelSize: { value: texelSize },
                        dt: { value: 0.016 },
                        dissipation: { value: CONFIG.VELOCITY_DISSIPATION }
                    }, vertexShader: baseVertexShader, fragmentShader: advectionShader
                }),
                divergence: new THREE.ShaderMaterial({
                    uniforms: { uVelocity: { value: null }, texelSize: { value: texelSize } },
                    vertexShader: baseVertexShader, fragmentShader: divergenceShader
                }),
                pressure: new THREE.ShaderMaterial({
                    uniforms: { uPressure: { value: null }, uDivergence: { value: null }, texelSize: { value: texelSize } },
                    vertexShader: baseVertexShader, fragmentShader: pressureShader
                }),
                gradientSubtract: new THREE.ShaderMaterial({
                    uniforms: { uPressure: { value: null }, uVelocity: { value: null }, texelSize: { value: texelSize } },
                    vertexShader: baseVertexShader, fragmentShader: gradientSubtractShader
                }),
                splat: new THREE.ShaderMaterial({
                    uniforms: {
                        uTarget: { value: null },
                        aspectRatio: { value: simWidth / simHeight },
                        color: { value: new THREE.Vector3() },
                        point: { value: new THREE.Vector2() },
                        radius: { value: CONFIG.SPLAT_RADIUS }
                    }, vertexShader: baseVertexShader, fragmentShader: splatShader
                }),
                display: new THREE.ShaderMaterial({
                    uniforms: {
                        uTexture: { value: null },
                        uVelocity: { value: null }, // Passed velocity for distortion
                        uISO: { value: 0.0 },
                        uAperture: { value: 0.5 },
                        uTime: { value: 0.0 },
                        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, // INIT HERE
                        uHue: { value: 0.0 },       // Dynamic Hue
                        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                        uMouseVel: { value: new THREE.Vector2() }
                    }, vertexShader: baseVertexShader, fragmentShader: displayShader
                })
            };

            // --- Interaction Logic (Blue Hour Camera) ---
            const mouse = new THREE.Vector2(0.5, 0.5);
            const lastMouse = new THREE.Vector2(0.5, 0.5);
            const currentVel = new THREE.Vector2(0, 0); // Smoothed velocity

            let shutterSpeed = 0.0; // 0.0 = Fast (High Dissipation), 1.0 = Slow (Low Dissipation)
            let currentHue = 0.0;
            let targetHue = 0.0;

            const uiFStop = document.getElementById('f-stop');
            const uiShutter = document.getElementById('shutter');
            const uiIso = document.getElementById('iso');

            function updateMouse(e) {
                mouse.x = e.clientX / window.innerWidth;
                mouse.y = 1.0 - (e.clientY / window.innerHeight);
            }
            window.addEventListener('mousemove', updateMouse);

            function splat(dest, source, point, color) {
                mesh.material = mat.splat;
                mat.splat.uniforms.uTarget.value = source.texture;
                mat.splat.uniforms.point.value = point;
                mat.splat.uniforms.color.value = color;
                renderer.setRenderTarget(dest);
                renderer.render(scene, camera);
            }

            function step(dt) {
                // Apply Dynamic Dissipation based on "Shutter Speed"
                // Dissipation must be < 1.0. 
                // 0.96 (Slower Decay) -> 0.998 (Slow Decay)
                const diss = THREE.MathUtils.lerp(0.96, 0.998, shutterSpeed);

                mat.advection.uniforms.dissipation.value = diss;

                // 1. Advect Velocity
                mesh.material = mat.advection;
                mat.advection.uniforms.uVelocity.value = velocity.read.texture;
                mat.advection.uniforms.uSource.value = velocity.read.texture;
                renderer.setRenderTarget(velocity.write);
                renderer.render(scene, camera);
                velocity.swap();

                // 2. Advect Density
                mat.advection.uniforms.uVelocity.value = velocity.read.texture;
                mat.advection.uniforms.uSource.value = density.read.texture;
                renderer.setRenderTarget(density.write);
                renderer.render(scene, camera);
                density.swap();

                // 3. Divergence
                mesh.material = mat.divergence;
                mat.divergence.uniforms.uVelocity.value = velocity.read.texture;
                renderer.setRenderTarget(divergence);
                renderer.render(scene, camera);

                // 4. Pressure Solve
                mesh.material = mat.pressure;
                mat.pressure.uniforms.uDivergence.value = divergence.texture;
                let pRead = pressure.read;
                let pWrite = pressure.write;
                for (let i = 0; i < CONFIG.PRESSURE_ITERATIONS; i++) {
                    mat.pressure.uniforms.uPressure.value = pRead.texture;
                    renderer.setRenderTarget(pWrite);
                    renderer.render(scene, camera);
                    let temp = pRead; pRead = pWrite; pWrite = temp;
                }
                pressure.read = pRead;
                pressure.write = pWrite;

                // 5. Gradient Subtract
                mesh.material = mat.gradientSubtract;
                mat.gradientSubtract.uniforms.uPressure.value = pressure.read.texture;
                mat.gradientSubtract.uniforms.uVelocity.value = velocity.read.texture;
                renderer.setRenderTarget(velocity.write);
                renderer.render(scene, camera);
                velocity.swap();

                // 6. Display (Updated Uniforms)
                mesh.material = mat.display;
                mat.display.uniforms.uTexture.value = density.read.texture;
                mat.display.uniforms.uVelocity.value = velocity.read.texture; // Pass Vel for Distortion
                mat.display.uniforms.uISO.value = mouse.x;
                mat.display.uniforms.uAperture.value = mouse.y;
                mat.display.uniforms.uTime.value = performance.now() * 0.001;
                mat.display.uniforms.uHue.value = currentHue; // Pass Hue
                // uResolution already initialized
                mat.display.uniforms.uMouse.value.copy(mouse);
                mat.display.uniforms.uMouseVel.value.copy(currentVel); // Pass Smoothed Vel

                renderer.setRenderTarget(null);
                renderer.render(scene, camera);
            }

            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);

                // --- Interaction Mechanics ---
                // 1. Calculate Velocity from Mouse movement
                const dx = mouse.x - lastMouse.x;
                const dy = mouse.y - lastMouse.y;

                // Splat!
                if (Math.abs(dx) > 0.0001 || Math.abs(dy) > 0.0001) {
                    // Color intensity proportional to speed
                    const v = Math.sqrt(dx * dx + dy * dy) * 100.0;

                    // Color: NO GLOW (Just density for distortion/structure, but invisible color)
                    // Original was: new THREE.Vector3(v, v, v * 0.9) -> Bright White/Peach
                    // New: Very subtle density, or just Velocity?
                    // User said "No Light Spot". So we reduce density injection color to near zero,
                    // OR we change the shader to not add density to final color as much.
                    // Let's inject a very weak density so the fluid mechanics still work (if density is needed for other things)
                    // but it won't be a bright light.
                    splat(density.write, density.read, mouse, new THREE.Vector3(v * 0.0, v * 0.0, v * 0.0)); // Zero visible ink
                    density.swap();

                    // Force: Push fluid (Keep physics strong)
                    splat(velocity.write, velocity.read, mouse, new THREE.Vector3(dx, dy, 0.0).multiplyScalar(200.0));
                    velocity.swap();
                }

                // Smoothed Velocity for Ripple Logic
                // Using same smoothing factor as original 0.05
                // But dx/dy are raw frame differences. 
                // Scale up for shader (0..1 range roughly)
                const frameVelX = dx * 100.0;
                const frameVelY = dy * 100.0;
                currentVel.x += (frameVelX - currentVel.x) * 0.05;
                currentVel.y += (frameVelY - currentVel.y) * 0.05;
                // Decay
                currentVel.x *= 0.95;
                currentVel.y *= 0.95;


                // Dynamic Hue Logic
                const velMag = Math.sqrt(currentVel.x * currentVel.x + currentVel.y * currentVel.y);
                targetHue = velMag * 0.5; // Scale intensity Reduced from 2.0 to 0.5 for SUBTLE shift
                currentHue += (targetHue - currentHue) * 0.02; // Slow hue shift

                // 2. Variable Shutter Speed Logic
                // Moving fast = Fast Shutter (Low exposure time) -> Shutter Value -> 0.0
                // Stationary = Slow Shutter (Long exposure) -> Shutter Value -> 1.0
                const instantaneousSpeed = velMag * 10.0; // Scale up

                // Target: If subtle movement, allow long exposure. If jerky, snap to fast shutter.
                const target = THREE.MathUtils.clamp(1.0 - instantaneousSpeed * 0.5, 0.0, 1.0);

                // Smoothing: Fast attack (darken quickly), Slow release (brighten slowly)
                if (target < shutterSpeed) {
                    shutterSpeed += (target - shutterSpeed) * 0.1; // Fast darkening
                } else {
                    shutterSpeed += (target - shutterSpeed) * 0.01; // Slow recovery (Long Exposure)
                }

                lastMouse.copy(mouse);

                // Sim Step
                step(0.016);

                // UI Update
                updateUI(mouse.y, mouse.x, shutterSpeed);
            }

            function updateUI(aperture, iso, shutter) {
                // ISO
                const isoVal = Math.floor(100 * Math.pow(2, iso * 5));
                uiIso.innerText = isoVal;
                uiIso.style.color = iso > 0.8 ? "red" : "#00ffcc";

                // Aperture
                const fStops = [1.4, 2.0, 2.8, 4.0, 5.6, 8.0, 11, 16, 22];
                // Invert logic: Top (1.0) = Open (f/1.4), Bottom (0.0) = Closed (f/22) ?? 
                // Let's match original: "fIndex = Floor((1.0 - aperture) * len)". So Aperture 1.0 -> f/1.4.
                const fIndex = Math.floor((1.0 - aperture) * (fStops.length - 1));
                uiFStop.innerText = "f/" + fStops[Math.max(0, Math.min(fIndex, fStops.length - 1))];

                // Shutter Display
                if (shutter > 0.9) uiShutter.innerText = "1/10";
                else if (shutter > 0.6) uiShutter.innerText = "1/60";
                else if (shutter > 0.3) uiShutter.innerText = "1/250";
                else uiShutter.innerText = "1/4000";
            }

            animate();

            // --- Screenshot ---
            // --- Shutter Animation & Screenshot ---
            const shutterOverlay = document.createElement('div');
            Object.assign(shutterOverlay.style, {
                position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
                pointerEvents: 'none', zIndex: '9999', display: 'none',
                background: '#111',
                // Simulate Blades with Conic Gradient
                backgroundImage: 'repeating-conic-gradient(from 0deg, #111 0deg 10deg, #1a1a1a 10deg 20deg)',
                backgroundSize: '100% 100%',
                // Mask for the Iris Hole
                maskImage: 'radial-gradient(circle, transparent 70%, black 70.5%)',
                webkitMaskImage: 'radial-gradient(circle, transparent 70%, black 70.5%)',
                maskRepeat: 'no-repeat',
                webkitMaskRepeat: 'no-repeat',
                maskPosition: 'center',
                webkitMaskPosition: 'center'
            });
            document.body.appendChild(shutterOverlay);

            let isShutterAnim = false;

            window.addEventListener('click', (e) => {
                if (e.target.tagName === 'A' || isShutterAnim) return;

                // 1. Capture immediately (before shutter obstructs)
                const dataURL = canvas.toDataURL('image/png');
                const date = new Date();
                const filename = `bluehour-fluid-${date.toISOString().replace(/[:.]/g, '-')}.png`;

                // 2. Play Shutter Animation
                isShutterAnim = true;
                shutterOverlay.style.display = 'block';

                let startTime = performance.now();
                const durationClose = 100; // Fast Close
                const durationHold = 50;   // Brief Blackout
                const durationOpen = 300;  // Slower Open

                function animateShutter(time) {
                    let elapsed = time - startTime;
                    let progress = 0;
                    let radius = 100; // Percentage

                    if (elapsed < durationClose) {
                        // Closing: 150% -> 0%
                        progress = elapsed / durationClose;
                        // Ease In Quart
                        progress = progress * progress * progress * progress;
                        radius = 150 * (1.0 - progress);
                    } else if (elapsed < durationClose + durationHold) {
                        // Closed
                        radius = 0;
                    } else if (elapsed < durationClose + durationHold + durationOpen) {
                        // Opening: 0% -> 150%
                        progress = (elapsed - durationClose - durationHold) / durationOpen;
                        // Ease Out Quart
                        progress = 1 - (--progress) * progress * progress * progress;
                        radius = 150 * progress;
                    } else {
                        // Finished
                        shutterOverlay.style.display = 'none';
                        isShutterAnim = false;

                        // 3. Trigger Download
                        const link = document.createElement('a');
                        link.download = filename;
                        link.href = dataURL;
                        link.click();
                        return;
                    }

                    const grad = `radial-gradient(circle, transparent ${radius}%, black ${radius + 0.5}%)`;
                    shutterOverlay.style.maskImage = grad;
                    shutterOverlay.style.webkitMaskImage = grad;

                    requestAnimationFrame(animateShutter);
                }

                requestAnimationFrame(animateShutter);
            });

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                mat.display.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            });
        </script>
    </body>

</html>